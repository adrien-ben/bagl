package com.adrien.games.bagl.rendering.particles;import com.adrien.games.bagl.core.Time;import com.adrien.games.bagl.rendering.BlendMode;import com.adrien.games.bagl.rendering.texture.Texture;import com.adrien.games.bagl.utils.AssertUtils;import org.joml.Vector3f;import org.joml.Vector3fc;import java.util.Objects;import java.util.Optional;import java.util.function.Consumer;/** * Particle emitter. * <p> * A particle emitter is responsible to spawn particles at a given rate. The * number of particles spawn and spawn rate can be configured. A emitter can * have a {@link Texture} associated, if so every particles spawn by this * emitter will be render with that texture. * <p> * A {@link Consumer} of {@link Particle} must be passed in when creating * the emitter it will be call for each spawned particle. Its purpose is to * initialize the particle. That initializer function will set a position * to the particle. That position is RELATIVE to the position of the emitter. * <p> * Each emitter holds its own particle pool to avoid instantiating to much * objects. */public class ParticleEmitter {    public static final int MAX_PARTICLE_COUNT = 10000;    private final Vector3f position;    private final Texture texture;    private final BlendMode blendMode;    private final float rate;    private final int batchSize;    private final Particle[] pool;    private float timeToNextBatch;    private final Consumer<Particle> initializer;    private ParticleEmitter(final Builder builder) {        this(builder.position, builder.texture, builder.blendMode, builder.rate, builder.batchSize, builder.initializer);    }    private ParticleEmitter(final Vector3f position, final Texture texture, final BlendMode blendMode, final float rate, final int batchSize, final Consumer<Particle> initializer) {        this.position = position;        this.texture = texture;        this.blendMode = blendMode;        this.rate = rate;        this.batchSize = batchSize;        this.timeToNextBatch = rate;        this.initializer = AssertUtils.validate(initializer, Objects::nonNull, "A particle emitter needs a particle initializer");        this.pool = initPool();    }    /**     * Returns a new builder for particle emitter.     */    public static Builder builder() {        return new Builder();    }    private Particle[] initPool() {        final var pool = new Particle[MAX_PARTICLE_COUNT];        for (var i = 0; i < MAX_PARTICLE_COUNT; i++) {            pool[i] = new Particle();        }        return pool;    }    /**     * Updates all the particles owned by this emitter and     * generates a new batch of particles if enough time as     * passed.     *     * @param time Game time.     */    public void update(Time time) {        for (final var p : this.pool) {            p.update(time);        }        this.timeToNextBatch -= time.getElapsedTime();        if (this.timeToNextBatch <= 0) {            this.generateBatch();        }    }    private void generateBatch() {        this.timeToNextBatch = this.rate;        int generated = 0;        for (int i = 0; i < MAX_PARTICLE_COUNT; i++) {            if (generated == this.batchSize) {                break;            }            final Particle p = this.pool[i];            if (!p.isAlive()) {                this.initializer.accept(p);                p.getPosition().add(this.position);                generated++;            }        }    }    public void setPosition(final Vector3fc position) {        this.position.set(position);    }    public Optional<Texture> getTexture() {        return Optional.ofNullable(this.texture);    }    public BlendMode getBlendMode() {        return this.blendMode;    }    public Particle[] getParticles() {        return this.pool;    }    /**     * Particle emitter builder.     * <p>     * Use it to build new {@link ParticleEmitter}. The fields are :     * <li>position - default = (0, 0, 0)</li>     * <li>texture - default = null</li>     * <li>blendMode - default = ADDITIVE</li>     * <li>rate - The rate at which new batch are generated - default = 1.0</li>     * <li>batchSize - Number of particle generated by batch - default = 1</li>     * <li>initializer - Particle initializer used to reset particles - required</li>     */    public static class Builder {        private Vector3f position = new Vector3f();        private Texture texture = null;        private BlendMode blendMode = BlendMode.ADDITIVE;        private float rate = 1.0f;        private int batchSize = 1;        private Consumer<Particle> initializer = null;        public ParticleEmitter build() {            return new ParticleEmitter(this);        }        public Builder position(final Vector3fc position) {            this.position.set(AssertUtils.validate(position, Objects::nonNull, "position should not be null"));            return this;        }        public Builder texture(final Texture texture) {            this.texture = texture;            return this;        }        public Builder blendMode(final BlendMode blendMode) {            this.blendMode = AssertUtils.validate(blendMode, Objects::nonNull, "blendMode should not be null");            return this;        }        public Builder rate(final float rate) {            this.rate = AssertUtils.validate(rate, r -> r > 0, "rate should be more than zero");            return this;        }        public Builder batchSize(final int batchSize) {            this.batchSize = AssertUtils.validate(batchSize, b -> b > 0, "batchSize should be more than zero");            return this;        }        public Builder initializer(final Consumer<Particle> initializer) {            this.initializer = AssertUtils.validate(initializer, Objects::nonNull, "initializer should not be null");            return this;        }    }}